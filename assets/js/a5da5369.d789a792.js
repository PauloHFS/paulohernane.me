"use strict";(self.webpackChunkpaulohernane_me=self.webpackChunkpaulohernane_me||[]).push([[6048],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(n),h=a,d=p["".concat(c,".").concat(h)]||p[h]||m[h]||o;return n?r.createElement(d,i(i({ref:t},u),{},{components:n})):r.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3481:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={id:"semaphore",title:"Semaphore",tags:["Concurrent Programming","Semaphore","Mutex","Exclusion","Race Condition","Rendezvous"]},i="Semaphore",l={unversionedId:"concurrent-programming/semaphore",id:"concurrent-programming/semaphore",title:"Semaphore",description:"Before understand what is a semaphore, we need to understand some concepts:",source:"@site/docs/concurrent-programming/semaphore.md",sourceDirName:"concurrent-programming",slug:"/concurrent-programming/semaphore",permalink:"/docs/concurrent-programming/semaphore",draft:!1,tags:[{label:"Concurrent Programming",permalink:"/docs/tags/concurrent-programming"},{label:"Semaphore",permalink:"/docs/tags/semaphore"},{label:"Mutex",permalink:"/docs/tags/mutex"},{label:"Exclusion",permalink:"/docs/tags/exclusion"},{label:"Race Condition",permalink:"/docs/tags/race-condition"},{label:"Rendezvous",permalink:"/docs/tags/rendezvous"}],version:"current",frontMatter:{id:"semaphore",title:"Semaphore",tags:["Concurrent Programming","Semaphore","Mutex","Exclusion","Race Condition","Rendezvous"]},sidebar:"myBrainSidebar",previous:{title:"Concurrent Programming",permalink:"/docs/concurrent-programming/"},next:{title:"Database",permalink:"/docs/databases/"}},c={},s=[{value:"Definition",id:"definition",level:2},{value:"Syntax",id:"syntax",level:3}],u={toc:s},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"semaphore"},"Semaphore"),(0,a.kt)("p",null,"Before understand what is a semaphore, we need to understand some concepts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Synchronization: Event A must happen before event B."),(0,a.kt)("li",{parentName:"ul"},"Mutual Exclusion: Event A and B must not happen at the same time.")),(0,a.kt)("p",null,"That are called synchronization constraints. So, because of the ",(0,a.kt)("a",{parentName:"p",href:"https://www.scaler.com/topics/operating-system/process-synchronization-in-os/"},"process synchronization of the Operation System (OS)"),", we can't guarantee that a process will run in a specific order. So, we need to use some techniques to guarantee that a process will run in a specific order. And this is the main goal of the semaphore."),(0,a.kt)("h2",{id:"definition"},"Definition"),(0,a.kt)("p",null,"Semaphore is a data structure created by Dijkstra that is useful for solving a variety of synchronization problems. It's like a integer, but with some peculiarities."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When you create a Semaphore you can initialize it with any integer."),(0,a.kt)("li",{parentName:"ul"},"Unlike a integer, you can only increment ",(0,a.kt)("inlineCode",{parentName:"li"},"(+1)")," and decrement ",(0,a.kt)("inlineCode",{parentName:"li"},"(-1)")," the value."),(0,a.kt)("li",{parentName:"ul"},"You can't read the current value of the semaphore."),(0,a.kt)("li",{parentName:"ul"},"When a thread decrement the semaphore, its check if the result of the operation is negative, if true the thread blocks itself (notify the kernel scheduler that it can't proceed) and cannot continue until another thread increment the thread."),(0,a.kt)("li",{parentName:"ul"},"When a thread increment the semaphore, its check if there are other threads waiting, one of then gets unblocked.")),(0,a.kt)("p",null,"By definition we can infer some facts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Cause we don't know the semaphore value there is no way to know if a decrement will block the thread."),(0,a.kt)("li",{parentName:"ul"},"After a thread increment a semaphore and another thread gets unlock/woken up, both threads now continue running concurrently. Theres is no way to now what thread will runs immediately (Thread A may unlock Thread B and lost CPU at that time, then the scheduler can set Thread B to get the CPU)."),(0,a.kt)("li",{parentName:"ul"},"When increment a semaphore you don't know if there is a thread waiting, so the number os threads that you can unlock maybe ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),".")),(0,a.kt)("p",null,"About what the value of the semaphore means:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"< 0")," - negative; this is the number of threads blocked and are waiting."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0")," - there is no thread waiting, but if a threads tries to decrements it will be blocked."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"> 0")," - positive; this is the number of threads that can decrement without blocking.")),(0,a.kt)("h3",{id:"syntax"},"Syntax"),(0,a.kt)("p",null,"The constructor sometimes can show up like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"function1Done = Semaphore(1)\n")),(0,a.kt)("p",null,"The increment:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"function1Done.increment()\nfunction1Done.signal()\nfunction1Done.up()\nfunction1Done.V() // Dijkstra proposed this, insane!\n")),(0,a.kt)("p",null,"The decrement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"function1Done.decrement()\nfunction1Done.wait()\nfunction1Done.down()\nfunction1Done.P() // Dijkstra again ;-; \n")))}m.isMDXComponent=!0}}]);